#!/usr/bin/env perl

use strict;
use utf8;
use warnings;
use Getopt::Long;
use Config::General;

use CIHM::Meta::REST::collection;
use CIHM::Meta::REST::manifest;
use CIHM::Meta::REST::slug;
use Data::Dumper;
use JSON;
use DateTime;
use List::Compare;
use File::chdir;
use URI::Escape;

my $conf = "/etc/canadiana/tdr/tdr.conf";
my $validate;

GetOptions(
    'conf:s'   => \$conf,
    'validate' => \$validate,
);

my %confighash = new Config::General( -ConfigFile => $conf, )->getall;

# Undefined if no <collection> config block
my $collectiondb;
if ( exists $confighash{collection} ) {
    $collectiondb = new CIHM::Meta::REST::collection(
        server      => $confighash{collection}{server},
        database    => $confighash{collection}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <collection> configuration block in config\n";
}

# Undefined if no <manifest> config block
my $manifestdb;
if ( exists $confighash{manifest} ) {
    $manifestdb = new CIHM::Meta::REST::manifest(
        server      => $confighash{manifest}{server},
        database    => $confighash{manifest}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <manifest> configuration block in config\n";
}

# Undefined if no <slug> config block
my $slugdb;
if ( exists $confighash{slug} ) {
    $slugdb = new CIHM::Meta::REST::slug(
        server      => $confighash{slug}{server},
        database    => $confighash{slug}{database},
        type        => 'application/json',
        conf        => $conf,
        clientattrs => { timeout => 36000 },
    );
}
else {
    die "Missing <slug> configuration block in config\n";
}

## Load existing 'slug' entries
print "Load slugs...\n";
my %collectionslugs;
my %manifestslugs;
my $res =
  $slugdb->get( "/" . $slugdb->database . "/_all_docs?include_docs=true",
    {}, { deserializer => 'application/json' } );
if ( $res->code != 200 ) {
    if ( defined $res->response->content ) {
        warn $res->response->content . "\n";
    }
    die "slug/_all_docs return code: " . $res->code . "\n";
}
foreach my $slugentry ( @{ $res->data->{rows} } ) {
    if ( substr( $slugentry->{key}, 0, 8 ) ne '_design/' ) {
        if ( $slugentry->{doc}->{type} eq 'manifest' ) {
            %{ $manifestslugs{ $slugentry->{key} } } = %{ $slugentry->{doc} };
        }
        else {
            %{ $collectionslugs{ $slugentry->{key} } } = %{ $slugentry->{doc} };
        }
    }
}
undef $res;

print scalar( keys %collectionslugs )
  . " collections and "
  . scalar( keys %manifestslugs )
  . " manifests\n";

processCollections();
processManifests();

sub processCollections {
    print "Processing Collections\n";

    foreach my $key ( keys %collectionslugs ) {
        my $slug = $collectionslugs{$key};
        my $noid = $slug->{noid};

        my $url = "/" . $collectiondb->database . "/" . uri_escape($noid);
        my $res = $collectiondb->get( $url,
            {}, { deserializer => 'application/json' } );
        if ( $res->code != 200 ) {
            if ( defined $res->response->content ) {
                warn $res->response->content . "\n";
            }
            die "collectiondb get of '$noid' ($url) return code: "
              . $res->code . "\n";
        }
        my $collection = $res->data;
        my $modified;
        if ( !defined $collection->{slug}
            || ( $collection->{slug} ne $slug->{'_id'} ) )
        {
            $modified = 1;
            $collection->{slug} = $slug->{'_id'};
        }
        if ( defined $slug->{'aliases'} ) {
            if ( !defined $collection->{aliasedSlugs} ) {
                $modified = 1;
                $collection->{aliasedSlugs} = $slug->{'aliases'};
            }
            else {
                my $lc = List::Compare->new( $collection->{aliasedSlugs},
                    $slug->{'aliases'} );
                if ( !( $lc->is_LequivalentR ) ) {
                    $modified = 1;
                    $collection->{aliasedSlugs} = $slug->{'aliases'};
                }
            }
        }

        if ($modified) {
            validateRecord( 'collection', $collection->{slug}, $collection )
              if ($validate);

            $res =
              $collectiondb->put( $url,
                $collection, { deserializer => 'application/json' } );
            if ( $res->code != 201 ) {
                if ( defined $res->response->content ) {
                    warn $res->response->content . "\n";
                }
                die "collectiondb put of '$noid' ($url) return code: "
                  . $res->code . "\n";
            }
        }
    }
}

sub processManifests {
    print "Processing Manifests\n";

    foreach my $key ( keys %manifestslugs ) {
        my $slug = $manifestslugs{$key};
        my $noid = $slug->{noid};

        my $url = "/" . $manifestdb->database . "/" . uri_escape($noid);
        my $res =
          $manifestdb->get( $url, {}, { deserializer => 'application/json' } );
        if ( $res->code != 200 ) {
            if ( defined $res->response->content ) {
                warn $res->response->content . "\n";
            }
            die "manifestdb get of '$noid' ($url) return code: "
              . $res->code . "\n";
        }
        my $manifest = $res->data;
        my $modified;

#  This seemed to be missing.  Apparently an update to Smelter is required as well.
        if (   !defined $manifest->{freezeParameters}
            && !defined $manifest->{frozen} )
        {
            $modified = 1;
            $manifest->{freezeParameters} = {};
        }

        if ( !defined $manifest->{slug}
            || ( $manifest->{slug} ne $slug->{'_id'} ) )
        {
            $modified = 1;
            $manifest->{slug} = $slug->{'_id'};
        }
        if ( defined $slug->{'aliases'} ) {
            if ( !defined $manifest->{aliasedSlugs} ) {
                $modified = 1;
                $manifest->{aliasedSlugs} = $slug->{'aliases'};
            }
            else {
                my $lc = List::Compare->new( $manifest->{aliasedSlugs},
                    $slug->{'aliases'} );
                if ( !( $lc->is_LequivalentR ) ) {
                    $modified = 1;
                    $manifest->{aliasedSlugs} = $slug->{'aliases'};
                }
            }
        }

        if ($modified) {
            validateRecord( 'manifest', $manifest->{slug}, $manifest )
              if ($validate);

            $res =
              $manifestdb->put( $url,
                $manifest, { deserializer => 'application/json' } );
            if ( $res->code != 201 ) {
                if ( defined $res->response->content ) {
                    warn $res->response->content . "\n";
                }
                die "manifestdb put of '$noid' ($url) return code: "
                  . $res->code . "\n";
            }
        }
    }
}

sub validateRecord {
    my ( $type, $slug, $record ) = @_;

    local $CWD = "/home/tdr/Databases";
    my $tempname = "/tmp/copyslugvalidate.json";

    open( FH, '>', $tempname ) or die $!;
    print FH encode_json($record);
    close(FH);

    my $results;
    open( FH, "node ./test.js -s schemas/$type.json -f $tempname |" ) or die $!;
    {
        local $/;
        $results = <FH>;
    }
    close(FH);
    chomp($results);
    if ( $results ne "You did it." ) {
        die(    "Validation failure for type=$type slug=$slug :\n"
              . Data::Dumper->Dump( [ $record, $results ], [qw(Record Result)] )
              . "\n" );
    }
    else {
        print "Validation of type=$type slug=$slug OK\n";
    }
}

